//
// Created by Alienware on 2022/2/13.
//


//给你一个字符串s和一个字符规律p，请你来实现一个支持 '.'和'*'的正则表达式匹配。
//
//'.' 匹配任意单个字符
//'*' 匹配零个或多个前面的那一个元素
//        所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。
//
//
//示例 1：
//
//输入：s = "aa", p = "a"
//输出：false
//解释："a" 无法匹配 "aa" 整个字符串。
//示例 2:
//
//输入：s = "aa", p = "a*"
//输出：true
//解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
//示例3：
//
//输入：s = "ab", p = ".*"
//输出：true
//解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

// 思路：
// 使用动态规划的思想
// 申请dp[s.length()][p.length()]大的bool数组
// 当前的i、j下标表示dp[i][j]是否为匹配的
// 可以设i为外层循环，j为内层循环
// 因此当前问题可以分解
// 若当前字母为'.'，则表明，若s、p的i-1，j-1之前的字符相匹配，则现在也是匹配的
// 依据上述思想
// 可以分为以下几种情况
// 1.当前匹配的字符相匹配
// 2.当前字符为'.'，表明若前一个字符之前相匹配，则现在也是匹配的
// 3.当前字符为'*'，此时存在以下几种情况
// 3.1 若p.at(j-2)为'.'，则表明，当前j-2和j-1可以匹配无限多字符，因此可以将设置为dp[i][j] = dp[i-1][j]
//      同时，由于不能使其无限匹配，因此还应当设置dp[i][j-2]，此时去掉'.*'两个字符
//      因此为dp[i][j] = dp[i-1][j] || dp[i][j-2]，他们之中只要有能使其匹配的，则表示可以匹配
// 3.2 若此时p.at(j-2) == s.at[i-1]，则此时表明，可以由j-2生成，因此可以继续保留*向前匹配，或将j-2和j-1都去掉
//      因此为dp[i][j] = dp[i-1][j] || dp[i][j-2]，他们之中只要有能使其匹配的，则表示可以匹配
// 3.3 若此时j-2也与i-1不匹配，则表明需要去掉j-2和j-1才有可能匹配
//      因此为dp[i][j] = dp[i][j-2]，他们之中只要有能使其匹配的，则表示可以匹配




# include <iostream>
# include <string.h>
using namespace std;

class Solution {
public:
    bool isMatch(string s, string p) {
        // 核心思想：让p在当前匹配处尽力匹配s
        int sLen = s.length();
        int pLen = p.length();
        // 动态规划数组
        // 数组是错位的，即第i(下标)个元素对应的dp下标为i+1
        bool dp[sLen + 1][pLen + 1];
        memset(dp, false, (sLen + 1) * (pLen + 1));
        dp[0][0] = true;
        // 当s为""时，消去*的项
        for (int i = 1; i <= pLen; i++) {
            if (p.at(i - 1) == '*')
                dp[0][i] = dp[0][i - 2];
        }
        for (int i = 1; i <= sLen; i++) {
            for (int j = 1; j <= pLen; j++) {
                // 最基本的情况，若两个字母相同
                if (p.at(j - 1) <= 'z' && p.at(j - 1) >= 'a') {
                    if (p.at(j - 1) == s.at(i - 1))
                        dp[i][j] = dp[i - 1][j - 1];
                }
                    // 若其为.则也算字母相同
                else if (p.at(j - 1) == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                    // 若其为*，则需要进行多种情况考虑
                else if (p.at(j - 1) == '*') {
                    // 判断其前一个字母和s[i-1]的关系
                    // p[j-2]=='.'或者与s[i-1]相同，则可以利用*扩展获得
                    if (p.at(j - 2) == '.' || p.at(j - 2) == s.at(i - 1)) {
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 2];
                    } else {
                        dp[i][j] = dp[i][j - 2];
                    }
                }
            }
        }
        return dp[sLen][pLen];
    }
};


int main() {
    Solution *solution = new Solution();
    cout << solution->isMatch("aa", "a*");
}